<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ImgTC | Admin</title>
  <!-- Import CSS -->
  <link rel="stylesheet" href="/static/admin-imgtc/style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.3/lib/theme-chalk/index.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css">
  <script src="https://js.sentry-cdn.com/219f636ac7bde5edab2c3e16885cb535.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="app">
    <el-container>
      <el-header>
        <div class="header-content">
          <span class="title" @click="refreshDashboard">Dashboard</span>
          <div class="search-card">
            <el-input v-model="search" size="mini" placeholder="输入关键字搜索"></el-input>
          </div>
          <el-tooltip content="批量上传" placement="bottom">
              <span class="stats" @click="handleUpload">
                <i class="fas fa-upload upload-icon"></i>记录数: {{ Number }}
              </span>
          </el-tooltip>
          <input type="file" ref="fileInput" style="display: none;" multiple @change="uploadFiles">
          <div class="actions">
            <el-tooltip content="文件类型" placement="bottom">
              <el-dropdown @command="switchFileType" :hide-on-click="false">
                <span class="el-dropdown-link">
                  <i :class="fileTypeIcon"></i>
                </span>
                <el-dropdown-menu slot="dropdown">
                  <el-dropdown-item command="image" :class="{ 'el-dropdown-menu__item--selected': fileType === 'image' }">
                    <i class="fas fa-image"></i> 图片
                  </el-dropdown-item>
                  <el-dropdown-item command="video" :class="{ 'el-dropdown-menu__item--selected': fileType === 'video' }">
                    <i class="fas fa-video"></i> 视频
                  </el-dropdown-item>
                  <el-dropdown-item command="audio" :class="{ 'el-dropdown-menu__item--selected': fileType === 'audio' }">
                    <i class="fas fa-music"></i> 音频
                  </el-dropdown-item>
                </el-dropdown-menu>
              </el-dropdown>
            </el-tooltip>
            <el-tooltip content="排序" placement="bottom">
              <el-dropdown @command="sort" :hide-on-click="false">
                <span class="el-dropdown-link">
                  <i :class="sortIcon"></i>
                </span>
                <el-dropdown-menu slot="dropdown">
                  <el-dropdown-item command="dateDesc" :class="{ 'el-dropdown-menu__item--selected': sortOption === 'dateDesc' }">按时间倒序</el-dropdown-item>
                  <el-dropdown-item command="nameAsc" :class="{ 'el-dropdown-menu__item--selected': sortOption === 'nameAsc' }">按名称升序</el-dropdown-item>
                </el-dropdown-menu>
              </el-dropdown>
            </el-tooltip>
            <el-tooltip content="收藏筛选" placement="bottom">
              <i class="fas fa-heart" :class="{ enabled: showFavorites }" @click="toggleFavorites" style="color: #FFD7E4;"></i>
            </el-tooltip>
            <el-tooltip content="全选当前页" placement="bottom">
              <i class="fas fa-check-square" @click="selectAllInPage"></i>
            </el-tooltip>
            <el-tooltip content="批量复制" placement="bottom">
              <i class="fas fa-link" :class="{ disabled: selectedFiles.length === 0 }" @click="handleBatchCopy"></i>
            </el-tooltip>
            <el-tooltip content="批量删除" placement="bottom">
              <i class="fas fa-trash-alt" :class="{ disabled: selectedFiles.length === 0 }" @click="handleBatchDelete"></i>
            </el-tooltip>
            <el-tooltip content="检测失效图片" placement="bottom">
              <i class="fas fa-wrench" @click="checkBrokenImages"></i>
            </el-tooltip>
            <el-tooltip content="退出登录" placement="bottom">
              <i class="fas fa-home" @click="handleLogout"></i>
            </el-tooltip>
          </div>
        </div>
      </el-header>
      <el-main class="main-container">
        <div class="content">
          <template v-for="(item, index) in paginatedTableData" :key="index">
            <!-- 非音频文件 -->
            <el-card class="image-card" v-if="fileType !== 'audio'">
              <span class="collect-icon" @click.stop="toggleLike(index, item.name)">
                <i :class="item.metadata.liked ? 'fa-solid fa-bookmark liked' : 'fa-regular fa-bookmark not-liked'"></i>
              </span>
              <el-checkbox v-model="item.selected" :ref="'checkbox-' + index"></el-checkbox>
              <template v-if="fileType === 'image'">
                <el-image
                  :src="'/file/' + item.name"
                  :preview-src-list="['/file/' + item.name]"
                  fit="cover"
                  lazy="true"
                ></el-image>
              </template>
              <template v-else-if="fileType === 'video'">
                <video
                  :src="'/file/' + item.name"
                  controls
                  style="width: 100%; height: 100%; object-fit: cover;"
                ></video>
              </template>
              <div class="image-overlay">
                <div class="overlay-buttons">
                  <el-button size="mini" type="primary" @click.stop="handleCopy(index, item.name)">复制地址</el-button>
                  <el-button size="mini" type="danger" @click.stop="handleDelete(index, item.name)">删除</el-button>
                </div>
              </div>
              <div class="card-footer">{{ item.name }}</div>
            </el-card>
            <el-card v-else class="audio-card"
              :class="{ 'selected': item.selected }"
              style="border-radius: 16px;"
            >

              <!-- 音频内容区域 -->
              <div class="audio-content">
                <!-- 音频标题和时长 -->
                <div class="audio-header">
                  <div class="audio-avatar">
                    <img src="/static/admin-imgtc/music.png" alt="Music">
                  </div>
                  <div class="audio-info">
                    <div class="audio-title">{{ item.name }}</div>
                    <div class="audio-subtitle">Audio File</div>
                  </div>
                </div>

                <!-- 进度条 -->
                <div class="audio-progress">
                  <div class="progress-bar"
                       ref="progressBar"
                       @mousedown="startDragging($event, index)"
                       @click.stop>
                    <div class="progress-track"></div>
                    <div class="progress-current"
                         :style="{ width: isDragging && currentDraggingIndex === index ?
                                  draggingProgress[index] + '%' :
                                  getProgress(index) + '%' }">
                    </div>
                    <div class="progress-handle"
                         :style="{ left: isDragging && currentDraggingIndex === index ?
                                  draggingProgress[index] + '%' :
                                  getProgress(index) + '%' }">
                    </div>
                  </div>
                  <div class="time-display">
                    <span>{{ getCurrentTime(index) }}</span>
                    <span>{{ getDuration(index) }}</span>
                  </div>
                </div>

                <!-- 控制按钮区 -->
                <div class="audio-controls">
                  <button class="control-btn like-btn" @click.stop="toggleLike(index, item.name)">
                    <i :class="item.metadata.liked ? 'fas fa-heart liked' : 'far fa-heart'" style="scale: 1.2;"></i>
                  </button>
                  <button class="control-btn select-btn" @click.stop="toggleSelect(index, item.name)">
                    <i :class="item.selected ? 'fas fa-square-check selected' : 'far fa-square'" style="scale: 1.2;"></i>
                  </button>
                  <!-- 播放按钮 -->
                  <button class="control-btn play-btn" @click.stop="togglePlay(index)">
                    <i :class="isPlaying(index) ? 'fas fa-pause' : 'fas fa-play'"></i>
                  </button>
                  <button class="control-btn" @click.stop="handleCopy(index, item.name)">
                    <i class="fas fa-link"></i>
                  </button>
                  <button class="control-btn" @click.stop="handleDelete(index, item.name)">
                    <i class="fas fa-trash-alt"></i>
                  </button>
                </div>
              </div>
              <audio
                :ref="'audio-' + index"
                :src="'/file/' + item.name"
                @loadedmetadata="initAudio($event, index)"
                @timeupdate="updateProgress($event, index)"
                @ended="onAudioEnded(index)"
                preload="metadata">
              </audio>
            </el-card>
          </template>
        </div>
        <div class="pagination-container">
          <el-pagination
            background
            layout="prev, pager, next"
            :total="filteredTableData.length"
            :page-size="pageSize"
            @current-change="handlePageChange"
            :current-page.sync="currentPage">
          </el-pagination>
        </div>
        <el-footer class="footer">
          <div>Powered By</div>
          <a href="https://github.com/cf-pages/Telegraph-Image" target="_blank" rel="noopener noreferrer">
            <div><i class="fa-brands fa-github"></i> Telegraph-Image</div>
          </a>
        </el-footer>
      </el-main>
    </el-container>
  </div>
</body>
<!-- Import Vue before Element -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
<!-- Import JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.3/lib/index.js"></script>
<script>
  new Vue({
    el: '#app',
    data: {
      baseURL: document.location.origin,
      Number: 0,
      tableData: [],
      search: '',
      currentPage: 1,
      pageSize: 15,
      selectedFiles: [],
      sortOption: 'dateDesc',
      showFavorites: false,
      fileType: 'image',
      hoveredIndex: null,
      isDragging: false,
      currentDraggingIndex: null,
      draggingProgress: {},
      audioStates: {}, // 用于存储音频状态
    },
    computed: {
      filteredTableData() {
        return this.tableData.filter(data => {
          const matchesSearch = !this.search || data.name.toLowerCase().includes(this.search.toLowerCase());
          const matchesFavorites = !this.showFavorites || data.metadata.liked;
          const extension = data.name.split('.').pop().toLowerCase();
          const fileTypes = {
            'image': ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'ico'],
            'video': ['mp4', 'webm', 'ogg', 'avi', 'mov', 'wmv', 'flv', 'mkv'],
            'audio': ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'wma']
          }
          return matchesSearch && matchesFavorites && fileTypes[this.fileType].includes(extension);
        });
      },
      paginatedTableData() {
        const sortedData = this.sortData(this.filteredTableData);
        const start = (this.currentPage - 1) * this.pageSize;
        const end = start + this.pageSize;
        return sortedData.slice(start, end);
      },
      sortIcon() {
        return this.sortOption === 'dateDesc' ? 'fas  fa-sort-amount-down' : 'fas fa-sort-alpha-up';
      },
      fileTypeIcon() {
        return this.fileType === 'image' ? 'fas fa-image' :
                this.fileType === 'video' ? 'fas fa-video' : 'fas fa-music';
      }
    },
    watch: {
      tableData: {
        handler(newData) {
          this.selectedFiles = newData.filter(file => file.selected);
        },
        deep: true
      },
      sortOption(newOption) {
        localStorage.setItem('sortOption', newOption);
      }
    },
    methods: {
      refreshDashboard() {
        location.reload();
      },
      calculatePageSize() {
        const minPageSize = 15;
        const cardMinWidth = 240; // 卡片最小宽度
        const cardAspectRatio = 3 / 4; // 卡片的高宽比
        const gap = 20; // 卡片间的间隙

        const contentElement = document.querySelector('.content');
        const containerWidth = contentElement ? contentElement.clientWidth : 800;
        const columns = Math.floor(containerWidth / (cardMinWidth + gap));

        const headerElement = document.querySelector('.header-content');
        const headerHeight = headerElement ? headerElement.offsetHeight : 60; // 使用默认值60px
        const containerHeight = window.innerHeight - headerHeight;
        const cardHeight = (containerWidth / columns - gap) * cardAspectRatio;
        const rows = Math.floor(containerHeight / (cardHeight + gap));

        this.pageSize = Math.max(rows * columns, minPageSize);
      },
      updateWindowWidth() {
        this.windowWidth = window.innerWidth;
        this.calculatePageSize();
      },
      toggleSelect(index, name) {
        const fileIndex = this.tableData.findIndex(file => file.name === name);
        this.tableData[fileIndex].selected = !this.tableData[fileIndex].selected;
      },
      startDragging(event, index) {
        event.preventDefault();
        this.isDragging = true;
        this.currentDraggingIndex = index;

        // 添加全局事件监听
        document.addEventListener('mousemove', this.onDragging);
        document.addEventListener('mouseup', this.stopDragging);

        // 初始化拖动位置
        this.updateDraggingProgress(event);
      },
      onDragging(event) {
        if (!this.isDragging) return;

        // 获取进度条元素
        const progressBar = this.$refs.progressBar[this.currentDraggingIndex];
        if (!progressBar) return;

        const rect = progressBar.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));

        this.$set(this.draggingProgress, this.currentDraggingIndex, percent);
      },
      stopDragging() {
        if (this.isDragging) {
          const audio = this.$refs[`audio-${this.currentDraggingIndex}`]?.[0];
          if (audio) {
            const progress = this.draggingProgress[this.currentDraggingIndex] || 0;
            audio.currentTime = (progress / 100) * audio.duration;
          }
        }

        // 清理状态和事件监听
        this.isDragging = false;
        this.currentDraggingIndex = null;
        document.removeEventListener('mousemove', this.onDragging);
        document.removeEventListener('mouseup', this.stopDragging);
      },
      updateDraggingProgress(event) {
        const progressBar = event.currentTarget;
        const rect = progressBar.getBoundingClientRect();
        const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
        const percent = (x / rect.width) * 100;
        this.$set(this.draggingProgress, this.currentDraggingIndex, percent);
      },
      handleUpload() {
        this.$refs.fileInput.click();
      },
      uploadFiles(event) {
        const files = event.target.files;
        if (files.length === 0) return;

        // 过滤文件类型和大小
        const validFiles = [];
        const invalidTypeFiles = [];
        const oversizedFiles = [];

        Array.from(files).forEach(file => {
          const isValidType = file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/');
          const isValidSize = file.size <= 5 * 1024 * 1024; // 5MB

          if (!isValidType) {
            invalidTypeFiles.push(file.name);
          } else if (!isValidSize) {
            oversizedFiles.push(file.name);
          } else {
            validFiles.push(file);
          }
        });

        // 显示错误消息
        if (invalidTypeFiles.length > 0) {
          this.$message.error(`以下文件类型不支持: ${invalidTypeFiles.join(', ')}`);
        }
        if (oversizedFiles.length > 0) {
          this.$message.error(`以下文件超过5MB: ${oversizedFiles.join(', ')}`);
        }
        if (validFiles.length === 0) {
          this.$message.info('没有符合条件的文件');
          return;
        }

        console.log("ValidFiles: ", validFiles);
        this.$confirm(`确定要上传这 ${validFiles.length} 个文件吗?`, '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          // 显示上传进度
          const loadingMessage = this.$message({
            message: '上传中...',
            duration: 0,
            showClose: false,
          });

          const maxConcurrent = 3; // 最大并发数
          let current = 0;
          let successCount = 0;
          let failedUploads = [];

          const uploadNext = () => {
            if (current >= validFiles.length) {
              // 检查是否所有文件都已处理
              if (successCount + failedUploads.length === validFiles.length) {
                loadingMessage.close();
                if (successCount > 0) {
                  this.$message.success(`成功上传 ${successCount} 个文件!`);
                }
                if (failedUploads.length > 0) {
                  this.$message.error(`上传失败: ${failedUploads.join(', ')}`);
                }
                // 刷新文件列表
                this.refreshFileList();
              }
              return;
            }

            const file = validFiles[current];
            current++;

            const formData = new FormData();
            formData.append('file', file);

            fetch(this.baseURL + '/upload', {
              method: 'POST',
              body: formData,
              credentials: 'include'
            }).then(response => {
              if (!response.ok) {
                return response.json().then(errorData => {
                  console.error('Upload error details:', errorData);
                  throw new Error(`上传失败: ${file.name} (${errorData.error || '未知错误'})`);
                });
              }
              return response.json();
            }).then(result => {
              if (Array.isArray(result) && result.length > 0 && result[0].error) {
                // 响应内容中包含错误
                throw new Error(result[0].error || `上传失败: ${file.name}`);
              }

              // 确保 result[0].src 存在
              if (!result[0].src) {
                throw new Error(`上传成功但未返回文件路径: ${file.name}`);
              }

              successCount++;

              // 处理成功上传的文件
              const previewUrl = `${this.baseURL}${result[0].src}`;
              if (result[0].src) {
                fetch(previewUrl, { method: 'GET', credentials: 'include' })
                  .then(response => {
                    if (!response.ok) {
                      console.error(`无法获取文件: ${previewUrl}`);
                    } else {
                      this.tableData.unshift({
                        name: result[0].src.replace(/^\/file\//, ''),
                        selected: false,
                        metadata: { TimeStamp: Date.now() }
                      });
                    }
                  }).catch(error => {
                    console.error(`获取文件时出错: ${previewUrl}`, error);
                  });
              }
            }).catch(error => {
              console.error('Upload error:', error);
              failedUploads.push(`${file.name} (${error.message})`);
            }).finally(() => {
              uploadNext(); // 继续上传下一个文件
            });
          };

          // 启动初始的并发上传任务
          for (let i = 0; i < maxConcurrent && i < validFiles.length; i++) {
            uploadNext();
          }

        }).catch(() => {
          this.$message.info('已取消上传');
        });

        // 清空文件输入，以便可以重复选择相同的文件
        event.target.value = '';
      },
      selectAllInPage() {
        const allSelected = this.paginatedTableData.every(file => file.selected);
        // 如果本页所有图片都已选中，则取消选中
        if (allSelected) {
          this.paginatedTableData.forEach(file => file.selected = false);
        } else {
          this.paginatedTableData.forEach(file => file.selected = true);
        }
      },
      refreshFileList() {
        // 重新获取文件列表
        fetch("./api/manage/list", { method: 'GET', credentials: 'include' })
          .then(response => response.json())
          .then(result => {
            this.tableData = result.map(file => ({ ...file, selected: false }));
            this.updateStats();
            this.sortData(this.tableData);
          })
          .catch(() => this.$message.error('刷新文件列表失败，请检查网络连接'));
      },
      handleDelete(index, key) {
        this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          fetch(`./api/manage/delete/${key}`, { method: 'GET', credentials: 'include' })
            .then(response => response.ok ? this.tableData.splice(index, 1) : Promise.reject())
            .then(() => {
              this.updateStats();
              this.$message.success('删除成功！');
            })
            .catch(() => this.$message.error('删除失败，请检查网络连接'));
        }).catch(() => this.$message.info('已取消删除'));
      },
      handleBatchDelete() {
        this.$confirm('此操作将永久删除这 ' + this.selectedFiles.length + ' 个文件, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }).then(() => {
          const promises = this.selectedFiles.map(file => fetch(`./api/manage/delete/${file.name}`, { method: 'GET', credentials: 'include' }));

          Promise.all(promises)
            .then(results => {
              results.forEach((response, index) => {
                if (response.ok) {
                  const fileIndex = this.tableData.findIndex(file => file.name === this.selectedFiles[index].name);
                  if (fileIndex !== -1) {
                    this.tableData.splice(fileIndex, 1);
                  }
                }
              });
              this.selectedFiles = [];
              this.updateStats();
              this.$message.success('批量删除成功!');
            })
            .catch(() => this.$message.error('批量删除失败，请检查网络连接'));
        }).catch(() => this.$message.info('已取消批量删除'));
      },
      handleBatchCopy() {
        const links = this.selectedFiles.map(file => `${document.location.origin}/file/${file.name}`).join('\n');
        navigator.clipboard ? navigator.clipboard.writeText(links).then(() => this.$message.success('批量复制链接成功~')) :
          this.copyToClipboardFallback(links);
      },
      copyToClipboardFallback(text) {
        const textarea = document.createElement('textarea');
        document.body.appendChild(textarea);
        textarea.style.position = 'fixed';
        textarea.style.clip = 'rect(0 0 0 0)';
        textarea.style.top = '10px';
        textarea.value = text;
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        this.$message.success('批量复制链接成功~');
      },
      handleLogout() {
        window.location.href = '/';
      },
      handleCopy(index, key) {
        const text = `${this.baseURL}/file/${key}`;
        navigator.clipboard ? navigator.clipboard.writeText(text).then(() => this.$message.success('复制文件链接成功~')) :
          this.copyToClipboardFallback(text);
      },
      handlePageChange(page) {
        this.currentPage = page;
      },
      toggleLike(index, name) {
        console.log(`Toggling like for image: ${name}`);

        // 找到对应文件的索引
        const fileIndex = this.tableData.findIndex(file => file.name === name);
        if (fileIndex === -1) return;

        // 乐观更新收藏状态
        if (this.tableData[fileIndex].metadata.liked === undefined) {
          this.tableData[fileIndex].metadata.liked = false;
        }
        this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;

        // 发送请求更新服务器数据
        var requestOptions = {
          method: 'GET',
          redirect: 'follow',
          credentials: 'include'
        };

        fetch(`./api/manage/toggleLike/${name}`, requestOptions)
          .then(response => response.json())
          .then(result => {
            if (!result.success) {
              // 如果服务器更新失败，将状态还原
              this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;
              this.$message({
                message: '更新收藏状态失败，请稍后重试',
                type: 'error'
              });
            } else {
              this.$message.success(this.tableData[fileIndex].metadata.liked ? '收藏成功' : '取消收藏');
            }
          })
          .catch(error => {
            console.error("An error occurred while synchronizing data with the server", error);
            // 如果服务器响应错误，将状态还原
            this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;
            this.$message({
              message: '同步服务器失败，请检查网络连接',
              type: 'error'
            });
          });
      },
      toggleFavorites() { // 筛选收藏图片
        this.showFavorites = !this.showFavorites;
        this.currentPage = 1;

        this.$message({
          message: (this.showFavorites ? '显示收藏' : '显示所有') + this.getFileTypeName(this.fileType),
          type: 'success',
          duration: 1500
        });
      },
      updateStats() {
        this.Number = this.tableData.length;
      },
      sort(command) {
        this.sortOption = command;
      },
      sortData(data) {
        return this.sortOption === 'nameAsc' ? data.sort((a, b) => a.name.localeCompare(b.name)) :
          data.sort((a, b) => b.metadata.TimeStamp - a.metadata.TimeStamp);
      },
      checkBrokenImages() {
        const loadingMessage = this.$message({
          message: '正在检测失效图片...',
          duration: 0,
          showClose: false,
        });

        let brokenCount = 0;
        const promises = this.tableData.map((item, index) => {
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve({ index, status: 'success' });
            img.onerror = () => {
              brokenCount++;
              this.tableData[index].selected = true;
              resolve({ index, status: 'error' });
            };
            img.src = `${this.baseURL}/file/${item.name}`;
          });
        });

        Promise.all(promises).then(() => {
          loadingMessage.close();
          if (brokenCount > 0) {
            this.$message({
              dangerouslyUseHTMLString: true,
              message: `检测到 ${brokenCount} 张失效图片，已自动选中。<br>您可以使用批量删除功能移除它们。`,
              type: 'warning',
              duration: 5000
            });
          } else {
            this.$message({
              message: '未检测到失效图片',
              type: 'success'
            });
          }
        });
      },
      switchFileType(type) {
        this.fileType = type;
        this.currentPage = 1;
        localStorage.setItem('fileType', type);
        this.$message({
          message: `已切换为 ${this.getFileTypeName(type)} 模式`,
          type: 'success',
          duration: 1500
        });
      },
      getFileTypeTypeName(type) {
        return type === 'image' ? '图片' : type === 'video' ? '视频' : '音频';
      },
      isPlaying(index) {
        const audio = this.$refs[`audio-${index}`]?.[0];
        return audio ? !audio.paused : false;
      },
      togglePlay(index) {
        const audio = this.$refs[`audio-${index}`]?.[0];
        if (!audio) return;

        // 暂停其他正在播放的音频
        Object.keys(this.$refs).forEach(key => {
          if (key.startsWith('audio-') && key !== `audio-${index}`) {
            const otherAudio = this.$refs[key][0];
            if (otherAudio && !otherAudio.paused) {
              otherAudio.pause();
            }
          }
        });

        if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
      },
      initAudio(event, index) {
        const audio = event.target;
        this.$set(this.audioStates, `duration-${index}`, this.formatTime(audio.duration));
      },
      updateProgress(event, index) {
        const audio = event.target;
        this.$set(this.audioStates, `currentTime-${index}`, audio.currentTime);
      },
      onAudioEnded(index) {
        this.$set(this.audioStates, `currentTime-${index}`, 0);
      },
      getCurrentTime(index) {
        const time = this.audioStates[`currentTime-${index}`] || 0;
        return this.formatTime(time);
      },
      getDuration(index) {
        return this.audioStates[`duration-${index}`] || '0:00';
      },
      getDraggingProgress(index) {
        if (this.isDragging && this.currentDraggingIndex === index) {
          return this.draggingProgress[index] || 0;
        }
        return this.getProgress(index);
      },
      getProgress(index) {
        const currentTime = this.audioStates[`currentTime-${index}`] || 0;
        const audio = this.$refs[`audio-${index}`]?.[0];
        if (!audio) return 0;
        return (currentTime / audio.duration) * 100 || 0;
      },
      seekAudio(event, index) {
        if (this.isDragging) return;

        const audio = this.$refs[`audio-${index}`]?.[0];
        if (!audio) return;

        const progressBar = event.currentTarget;
        const rect = progressBar.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percent = x / rect.width;

        audio.currentTime = percent * audio.duration;
      },
      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      },
    },
    mounted() {
      window.addEventListener('resize', this.calculatePageSize);
      this.updateWindowWidth();
      fetch("./api/manage/check", { method: 'GET', credentials: 'include' })
        .then(response => response.text())
        .then(result => result === "true" ? this.showLogoutButton = true : window.location.href = "./api/manage/login")
        .catch(() => this.$message.error('同步数据时出错，请检查网络连接'));

      fetch("./api/manage/list", { method: 'GET', credentials: 'include' })
        .then(response => response.json())
        .then(result => {
          console.log("result: ", result);
          this.tableData = result.map(file => ({
            ...file,
            selected: false,
            metadata: {
              ...file.metadata,
              liked: file.metadata.liked ?? false
            }
          }));
          this.updateStats();
          const savedSortOption = localStorage.getItem('sortOption');
          if (savedSortOption) {
            this.sortOption = savedSortOption;
          }
          this.sortData(this.tableData);
        })
        .catch(() => this.$message.error('同步数据时出错，请检查网络连接'));

      // 恢复用户偏好的文件类型
      const savedFileType = localStorage.getItem('fileType');
      if (savedFileType) {
        this.switchFileType(savedFileType);
      }
    },
    beforeDestroy() {
      window.removeEventListener('resize', this.calculatePageSize);
      // 清理音频资源
      Object.keys(this.$refs).forEach(key => {
        if (key.startsWith('audio-')) {
          const audio = this.$refs[key][0];
          if (audio) {
            audio.pause();
            audio.src = '';
          }
        }
      });
      // 确保清理全局事件监听
      document.removeEventListener('mousemove', this.onDragging);
      document.removeEventListener('mouseup', this.stopDragging);
    }
  });
</script>
</html>