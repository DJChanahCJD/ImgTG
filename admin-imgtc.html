  <!DOCTYPE html>
  <html lang="zh">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ImgTC | Admin</title>
    <!-- Import CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.3/lib/theme-chalk/index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css">
    <link rel="stylesheet" href="styles/admin-imgtc.css">
    <script src="https://js.sentry-cdn.com/219f636ac7bde5edab2c3e16885cb535.min.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <div id="app">
      <el-container>
        <el-header>
          <div class="header-content">
            <span class="title" @click="refreshDashboard">Dashboard</span>
            <div class="search-card">
              <el-input v-model="search" size="mini" placeholder="输入关键字搜索"></el-input>
            </div>
            <el-tooltip content="批量上传" placement="bottom">
                <span class="stats" @click="handleUpload">
                  <i class="fas fa-upload upload-icon"></i>记录数: {{ Number }}
                </span>
            </el-tooltip>
            <input type="file" ref="fileInput" style="display: none;" multiple @change="uploadFiles">
            <div class="actions">
              <el-tooltip content="文件类型" placement="bottom">
                <el-dropdown @command="switchFileType" :hide-on-click="false">
                  <span class="el-dropdown-link">
                    <i :class="fileTypeIcon"></i>
                  </span>
                  <el-dropdown-menu slot="dropdown">
                    <el-dropdown-item command="image" :class="{ 'el-dropdown-menu__item--selected': fileType === 'image' }">
                      <i class="fas fa-image"></i> 图片
                    </el-dropdown-item>
                    <el-dropdown-item command="video" :class="{ 'el-dropdown-menu__item--selected': fileType === 'video' }">
                      <i class="fas fa-video"></i> 视频
                    </el-dropdown-item>
                    <el-dropdown-item command="audio" :class="{ 'el-dropdown-menu__item--selected': fileType === 'audio' }">
                      <i class="fas fa-music"></i> 音频
                    </el-dropdown-item>
                  </el-dropdown-menu>
                </el-dropdown>
              </el-tooltip>
              <el-tooltip content="排序" placement="bottom">
                <el-dropdown @command="sort" :hide-on-click="false">
                  <span class="el-dropdown-link">
                    <i :class="sortIcon"></i>
                  </span>
                  <el-dropdown-menu slot="dropdown">
                    <el-dropdown-item command="dateDesc" :class="{ 'el-dropdown-menu__item--selected': sortOption === 'dateDesc' }">按时间倒序</el-dropdown-item>
                    <el-dropdown-item command="nameAsc" :class="{ 'el-dropdown-menu__item--selected': sortOption === 'nameAsc' }">按名称升序</el-dropdown-item>
                  </el-dropdown-menu>
                </el-dropdown>
              </el-tooltip>
              <el-tooltip content="收藏筛选" placement="bottom">
                <i class="fas fa-heart" :class="{ enabled: showFavorites }" @click="toggleFavorites"></i>
              </el-tooltip>
              <el-tooltip content="全选当前页" placement="bottom">
                <i class="fas fa-check-square" @click="selectAllInPage"></i>
              </el-tooltip>
              <el-tooltip content="批量复制" placement="bottom">
                <i class="fas fa-link" :class="{ disabled: selectedFiles.length === 0 }" @click="handleBatchCopy"></i>
              </el-tooltip>
              <el-tooltip content="批量删除" placement="bottom">
                <i class="fas fa-trash-alt" :class="{ disabled: selectedFiles.length === 0 }" @click="handleBatchDelete"></i>
              </el-tooltip>
              <el-tooltip content="检测失效图片" placement="bottom">
                <i class="fas fa-wrench" @click="checkBrokenImages"></i>
              </el-tooltip>
              <el-tooltip content="退出登录" placement="bottom">
                <i class="fas fa-home" @click="handleLogout"></i>
              </el-tooltip>
            </div>
          </div>
        </el-header>
        <el-main class="main-container">
          <div class="content">
            <template v-for="(item, index) in paginatedTableData" :key="index">
              <!-- 音频文件使用音频播放器组件 -->
              <template v-if="getFileType(item.name) === 'audio'">
                <audio-player
                  :src="'/file/' + item.name"
                  :file-name="item.name"
                  :metadata="item.metadata"
                  :selected="item.selected"
                  @toggle-like="toggleLike(index, item.name)"
                  @copy="handleCopy(index, item.name)"
                  @delete="handleDelete(index, item.name)"
                  @select="item.selected = !item.selected"
                ></audio-player>
              </template>
              <!-- 其他类型文件使用原有的卡片样式 -->
              <template v-else>
                <el-card>
                  <span class="collect-icon" @click.stop="toggleLike(index, item.name)">
                    <i :class="item.metadata.liked ? 'fa-solid fa-bookmark liked' : 'fa-regular fa-bookmark not-liked'"></i>
                  </span>
                  <el-checkbox v-model="item.selected" :ref="'checkbox-' + index"></el-checkbox>
                  <!-- 根据文件类型显示不同的媒体元素 -->
                  <template v-if="fileType === 'image'">
                    <el-image
                      :src="'/file/' + item.name"
                      :preview-src-list="['/file/' + item.name]"
                      fit="cover"
                      lazy="true"
                    ></el-image>
                  </template>
                  <template v-else-if="fileType === 'video'">
                    <video
                      :src="'/file/' + item.name"
                      controls
                      style="width: 100%; height: 100%; object-fit: cover;"
                    ></video>
                  </template>
                  <template v-else>
                    <audio-player
                      :src="'/file/' + item.name"
                      :file-name="item.name"
                    ></audio-player>
                  </template>
                  <div class="image-overlay">
                    <div class="overlay-buttons">
                      <el-button size="mini" type="primary" @click.stop="handleCopy(index, item.name)">复制地址</el-button>
                      <el-button size="mini" type="danger" @click.stop="handleDelete(index, item.name)">删除</el-button>
                    </div>
                  </div>
                  <div class="file-info">{{ item.name }}</div>
                </el-card>
              </template>
            </template>
          </div>
          <div class="pagination-container">
            <el-pagination
              background
              layout="prev, pager, next"
              :total="filteredTableData.length"
              :page-size="pageSize"
              @current-change="handlePageChange"
              :current-page.sync="currentPage">
            </el-pagination>
          </div>
          <el-footer class="footer">
            <div>Powered By</div>
            <a href="https://github.com/cf-pages/Telegraph-Image" target="_blank" rel="noopener noreferrer">
              <div><i class="fa-brands fa-github"></i> Telegraph-Image</div>
            </a>
          </el-footer>
        </el-main>
      </el-container>
    </div>
  </body>
  <!-- Import Vue before Element -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
  <!-- Import JavaScript -->
  <script src="https://cdn.jsdelivr.net/npm/element-ui@2.15.3/lib/index.js"></script>
  <script>
    // 注册音频播放器组件
    Vue.component('audio-player', {
      template: `
        <div class="audio-card">
          <span class="collect-icon" @click.stop="$emit('toggle-like')">
            <i :class="metadata.liked ? 'fa-solid fa-bookmark liked' : 'fa-regular fa-bookmark not-liked'"></i>
          </span>
          <el-checkbox v-model="selected" @change="$emit('select')"></el-checkbox>

          <div class="audio-player" :class="{ 'is-playing': isPlaying }">
            <div class="player-content">
              <div class="player-info">
                <i class="fas fa-music player-icon"></i>
                <span class="file-name" :title="fileName">{{ formatFileName }}</span>
              </div>
              <div class="player-controls">
                <button class="play-btn" @click.stop="togglePlay">
                  <i :class="isPlaying ? 'fas fa-pause' : 'fas fa-play'"></i>
                </button>
                <div class="progress-bar" @click.stop="seek">
                  <div class="progress" :style="{ width: progress + '%' }"></div>
                </div>
                <span class="time">{{ currentTime }}/{{ duration }}</span>
              </div>
            </div>
          </div>

          <div class="audio-overlay">
            <div class="overlay-buttons">
              <el-button size="mini" type="primary" @click.stop="$emit('copy')">复制地址</el-button>
              <el-button size="mini" type="danger" @click.stop="$emit('delete')">删除</el-button>
            </div>
          </div>

          <div class="file-info">{{ fileName }}</div>
        </div>
      `,
      props: {
        src: String,
        fileName: String,
        metadata: Object,
        selected: Boolean
      },
      data() {
        return {
          audio: null,
          isPlaying: false,
          progress: 0,
          currentTime: '0:00',
          duration: '0:00'
        }
      },
      mounted() {
        this.initAudio();
      },
      beforeDestroy() {
        this.destroyAudio();
      },
      methods: {
        initAudio() {
          this.audio = new Audio(this.src);
          this.audio.addEventListener('timeupdate', this.updateProgress);
          this.audio.addEventListener('loadedmetadata', this.setDuration);
          this.audio.addEventListener('ended', this.onEnded);
        },
        destroyAudio() {
          if (this.audio) {
            this.audio.removeEventListener('timeupdate', this.updateProgress);
            this.audio.removeEventListener('loadedmetadata', this.setDuration);
            this.audio.removeEventListener('ended', this.onEnded);
            this.audio.pause();
            this.audio = null;
          }
        },
        togglePlay() {
          if (this.isPlaying) {
            this.audio.pause();
          } else {
            this.audio.play();
          }
          this.isPlaying = !this.isPlaying;
        },
        formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        },
        updateProgress() {
          const { currentTime, duration } = this.audio;
          this.progress = (currentTime / duration) * 100;
          this.currentTime = this.formatTime(currentTime);
        },
        setDuration() {
          this.duration = this.formatTime(this.audio.duration);
        },
        seek(event) {
          const { left, width } = event.currentTarget.getBoundingClientRect();
          const clickPosition = (event.clientX - left) / width;
          this.audio.currentTime = clickPosition * this.audio.duration;
        },
        onEnded() {
          this.isPlaying = false;
          this.progress = 0;
        }
      }
    });

    // 主应用实例
    new Vue({
      el: '#app',
      data: {
        baseURL: document.location.origin,
        Number: 0,
        tableData: [],
        search: '',
        currentPage: 1,
        pageSize: 15,
        selectedFiles: [],
        sortOption: 'dateDesc',
        showFavorites: false,
        fileType: 'image',
      },
      computed: {
        filteredTableData() {
          return this.tableData.filter(data => {
            const matchesSearch = !this.search || data.name.toLowerCase().includes(this.search.toLowerCase());
            const matchesFavorites = !this.showFavorites || data.metadata.liked;
            const extension = data.name.split('.').pop().toLowerCase();
            const fileTypes = {
              'image': ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'ico'],
              'video': ['mp4', 'webm', 'ogg', 'avi', 'mov', 'wmv', 'flv', 'mkv'],
              'audio': ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'wma']
            }
            return matchesSearch && matchesFavorites && fileTypes[this.fileType].includes(extension);
          });
        },
        paginatedTableData() {
          const sortedData = this.sortData(this.filteredTableData);
          const start = (this.currentPage - 1) * this.pageSize;
          const end = start + this.pageSize;
          return sortedData.slice(start, end);
        },
        sortIcon() {
          return this.sortOption === 'dateDesc' ? 'fas  fa-sort-amount-down' : 'fas fa-sort-alpha-up';
        },
        fileTypeIcon() {
          return this.fileType === 'image' ? 'fas fa-image' :
                 this.fileType === 'video' ? 'fas fa-video' : 'fas fa-music';
        },
        processedTableData() {
          return this.tableData.map(item => ({
            ...item,
            type: this.getFileType(item.name),
            props: this.getMediaProps(item)
          }));
        }
      },
      watch: {
        tableData: {
          handler(newData) {
            this.selectedFiles = newData.filter(file => file.selected);
          },
          deep: true
        },
        sortOption(newOption) {
          localStorage.setItem('sortOption', newOption);
        }
      },
      methods: {
        refreshDashboard() {
          location.reload();
        },
        calculatePageSize() {
          const minPageSize = 15;
          const cardMinWidth = 240; // 卡片最小宽度
          const cardAspectRatio = 3 / 4; // 卡片的高宽比
          const gap = 20; // 卡片间的间隙

          const contentElement = document.querySelector('.content');
          const containerWidth = contentElement ? contentElement.clientWidth : 800;
          const columns = Math.floor(containerWidth / (cardMinWidth + gap));

          const headerElement = document.querySelector('.header-content');
          const headerHeight = headerElement ? headerElement.offsetHeight : 60; // 使用默认值60px
          const containerHeight = window.innerHeight - headerHeight;
          const cardHeight = (containerWidth / columns - gap) * cardAspectRatio;
          const rows = Math.floor(containerHeight / (cardHeight + gap));

          this.pageSize = Math.max(rows * columns, minPageSize);
        },
        updateWindowWidth() {
          this.windowWidth = window.innerWidth;
          this.calculatePageSize();
        },
        handleUpload() {
          this.$refs.fileInput.click();
        },
        uploadFiles(event) {
          const files = event.target.files;
          if (files.length === 0) return;

          // 过滤文件类型和大小
          const validFiles = [];
          const invalidTypeFiles = [];
          const oversizedFiles = [];

          Array.from(files).forEach(file => {
            const isValidType = file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/');
            const isValidSize = file.size <= 5 * 1024 * 1024; // 5MB

            if (!isValidType) {
              invalidTypeFiles.push(file.name);
            } else if (!isValidSize) {
              oversizedFiles.push(file.name);
            } else {
              validFiles.push(file);
            }
          });

          // 显示错误消息
          if (invalidTypeFiles.length > 0) {
            this.$message.error(`以下文件类型不支持: ${invalidTypeFiles.join(', ')}`);
          }
          if (oversizedFiles.length > 0) {
            this.$message.error(`以下文件超过5MB: ${oversizedFiles.join(', ')}`);
          }
          if (validFiles.length === 0) {
            this.$message.info('没有符合条件的文件');
            return;
          }

          console.log("ValidFiles: ", validFiles);
          this.$confirm(`确定要上传这 ${validFiles.length} 个文件吗?`, '提示', {
            confirmButtonText: '确定',
            cancelButtonText: '取消',
            type: 'warning'
          }).then(() => {
            // 显示上传进度
            const loadingMessage = this.$message({
              message: '上传中...',
              duration: 0,
              showClose: false,
            });

            const maxConcurrent = 3; // 最大并发数
            let current = 0;
            let successCount = 0;
            let failedUploads = [];

            const uploadNext = () => {
              if (current >= validFiles.length) {
                // 检查是否所有文件都已处理
                if (successCount + failedUploads.length === validFiles.length) {
                  loadingMessage.close();
                  if (successCount > 0) {
                    this.$message.success(`成功上传 ${successCount} 个文件!`);
                  }
                  if (failedUploads.length > 0) {
                    this.$message.error(`上传失败: ${failedUploads.join(', ')}`);
                  }
                  // 刷新文件列表
                  this.refreshFileList();
                }
                return;
              }

              const file = validFiles[current];
              current++;

              const formData = new FormData();
              formData.append('file', file);

              fetch(this.baseURL + '/upload', {
                method: 'POST',
                body: formData,
                credentials: 'include'
              }).then(response => {
                if (!response.ok) {
                  return response.json().then(errorData => {
                    console.error('Upload error details:', errorData);
                    throw new Error(`上传失败: ${file.name} (${errorData.error || '未知错误'})`);
                  });
                }
                return response.json();
              }).then(result => {
                if (Array.isArray(result) && result.length > 0 && result[0].error) {
                  // 响应内容中包含错误
                  throw new Error(result[0].error || `上传失败: ${file.name}`);
                }

                // 确保 result[0].src 存在
                if (!result[0].src) {
                  throw new Error(`上传成功但未返回文件路径: ${file.name}`);
                }

                successCount++;

                // 处理成功上传的文件
                const previewUrl = `${this.baseURL}${result[0].src}`;
                if (result[0].src) {
                  fetch(previewUrl, { method: 'GET', credentials: 'include' })
                    .then(response => {
                      if (!response.ok) {
                        console.error(`无法获取文件: ${previewUrl}`);
                      } else {
                        this.tableData.unshift({
                          name: result[0].src.replace(/^\/file\//, ''),
                          selected: false,
                          metadata: { TimeStamp: Date.now() }
                        });
                      }
                    }).catch(error => {
                      console.error(`获取文件时出错: ${previewUrl}`, error);
                    });
                }
              }).catch(error => {
                console.error('Upload error:', error);
                failedUploads.push(`${file.name} (${error.message})`);
              }).finally(() => {
                uploadNext(); // 继续上传下一个文件
              });
            };

            // 启动初始的并发上传任务
            for (let i = 0; i < maxConcurrent && i < validFiles.length; i++) {
              uploadNext();
            }

          }).catch(() => {
            this.$message.info('已取消上传');
          });

          // 清空文件输入，以便可以重复选择相同的文件
          event.target.value = '';
        },
        selectAllInPage() {
          const allSelected = this.paginatedTableData.every(file => file.selected);
          // 如果本页所有图片都已选中，则取消选中
          if (allSelected) {
            this.paginatedTableData.forEach(file => file.selected = false);
          } else {
            this.paginatedTableData.forEach(file => file.selected = true);
          }
        },
        refreshFileList() {
          // 重新获取文件列表
          fetch("./api/manage/list", { method: 'GET', credentials: 'include' })
            .then(response => response.json())
            .then(result => {
              this.tableData = result.map(file => ({ ...file, selected: false }));
              this.updateStats();
              this.sortData(this.tableData);
            })
            .catch(() => this.$message.error('刷新文件列表失败，请检查网络连接'));
        },
        handleDelete(index, key) {
          this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {
            confirmButtonText: '确定',
            cancelButtonText: '取消',
            type: 'warning'
          }).then(() => {
            fetch(`./api/manage/delete/${key}`, { method: 'GET', credentials: 'include' })
              .then(response => response.ok ? this.tableData.splice(index, 1) : Promise.reject())
              .then(() => {
                this.updateStats();
                this.$message.success('删除成功！');
              })
              .catch(() => this.$message.error('删除失败，请检查网络连接'));
          }).catch(() => this.$message.info('已取消删除'));
        },
        handleBatchDelete() {
          this.$confirm('此操作将永久删除这 ' + this.selectedFiles.length + ' 个文件, 是否继续?', '提示', {
            confirmButtonText: '确定',
            cancelButtonText: '取消',
            type: 'warning'
          }).then(() => {
            const promises = this.selectedFiles.map(file => fetch(`./api/manage/delete/${file.name}`, { method: 'GET', credentials: 'include' }));

            Promise.all(promises)
              .then(results => {
                results.forEach((response, index) => {
                  if (response.ok) {
                    const fileIndex = this.tableData.findIndex(file => file.name === this.selectedFiles[index].name);
                    if (fileIndex !== -1) {
                      this.tableData.splice(fileIndex, 1);
                    }
                  }
                });
                this.selectedFiles = [];
                this.updateStats();
                this.$message.success('批量删除成功!');
              })
              .catch(() => this.$message.error('批量删除失败，请检查网络连接'));
          }).catch(() => this.$message.info('已取消批量删除'));
        },
        handleBatchCopy() {
          const links = this.selectedFiles.map(file => `${document.location.origin}/file/${file.name}`).join('\n');
          navigator.clipboard ? navigator.clipboard.writeText(links).then(() => this.$message.success('批量复制链接成功~')) :
            this.copyToClipboardFallback(links);
        },
        copyToClipboardFallback(text) {
          const textarea = document.createElement('textarea');
          document.body.appendChild(textarea);
          textarea.style.position = 'fixed';
          textarea.style.clip = 'rect(0 0 0 0)';
          textarea.style.top = '10px';
          textarea.value = text;
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          this.$message.success('批量复制链接成功~');
        },
        handleLogout() {
          window.location.href = '/';
        },
        handleCopy(index, key) {
          const text = `${this.baseURL}/file/${key}`;
          navigator.clipboard ? navigator.clipboard.writeText(text).then(() => this.$message.success('复制文件链接成功~')) :
            this.copyToClipboardFallback(text);
        },
        handlePageChange(page) {
          this.currentPage = page;
        },
        toggleLike(index, name) {
          console.log(`Toggling like for image: ${name}`);

          // 找到对应文件的索引
          const fileIndex = this.tableData.findIndex(file => file.name === name);
          if (fileIndex === -1) return;

          // 乐观更新收藏状态
          if (this.tableData[fileIndex].metadata.liked === undefined) {
            this.tableData[fileIndex].metadata.liked = false;
          }
          this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;

          // 发送请求更新服务器数据
          var requestOptions = {
            method: 'GET',
            redirect: 'follow',
            credentials: 'include'
          };

          fetch(`./api/manage/toggleLike/${name}`, requestOptions)
            .then(response => response.json())
            .then(result => {
              if (!result.success) {
                // 如果服务器更新失败，将状态还原
                this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;
                this.$message({
                  message: '更新收藏状态失败，请稍后重试',
                  type: 'error'
                });
              } else {
                this.$message.success(this.tableData[fileIndex].metadata.liked ? '收藏成功' : '取消收藏');
              }
            })
            .catch(error => {
              console.error("An error occurred while synchronizing data with the server", error);
              // 如果服务器响应错误，将状态还原
              this.tableData[fileIndex].metadata.liked = !this.tableData[fileIndex].metadata.liked;
              this.$message({
                message: '同步服务器失败，请检查网络连接',
                type: 'error'
              });
            });
        },
        toggleFavorites() { // 筛选收藏图片
          this.showFavorites = !this.showFavorites;
          this.currentPage = 1;

          this.$message({
            message: this.showFavorites ? '已筛选收藏图片' : '显示全部图片',
            type: 'success',
            duration: 1500
          });
        },
        updateStats() {
          this.Number = this.tableData.length;
        },
        sort(command) {
          this.sortOption = command;
        },
        sortData(data) {
          return this.sortOption === 'nameAsc' ? data.sort((a, b) => a.name.localeCompare(b.name)) :
            data.sort((a, b) => b.metadata.TimeStamp - a.metadata.TimeStamp);
        },
        checkBrokenImages() {
          const loadingMessage = this.$message({
            message: '正在检测失效图片...',
            duration: 0,
            showClose: false,
          });

          let brokenCount = 0;
          const promises = this.tableData.map((item, index) => {
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => resolve({ index, status: 'success' });
              img.onerror = () => {
                brokenCount++;
                this.tableData[index].selected = true;
                resolve({ index, status: 'error' });
              };
              img.src = `${this.baseURL}/file/${item.name}`;
            });
          });

          Promise.all(promises).then(() => {
            loadingMessage.close();
            if (brokenCount > 0) {
              this.$message({
                dangerouslyUseHTMLString: true,
                message: `检测到 ${brokenCount} 张失效图片，已自动选中。<br>您可以使用批量删除功能移除它们。`,
                type: 'warning',
                duration: 5000
              });
            } else {
              this.$message({
                message: '未检测到失效图片',
                type: 'success'
              });
            }
          });
        },
        switchFileType(type) {
          this.fileType = type;
          this.currentPage = 1;
          localStorage.setItem('fileType', type);
          this.$message({
            message: `已切换为 ${this.getFileTypeName(type)} 模式`,
            type: 'success',
            duration: 1500
          });
        },
        getFileTypeTypeName(type) {
          return type === 'image' ? '图片' : type === 'video' ? '视频' : '音频';
        },
        getFileType(filename) {
          // 首先判断文件是否存在
          if (!filename) return 'unknown';

          const extension = filename.split('.').pop().toLowerCase();

          // 定义文件类型映射
          const typeMap = {
            // 图片类型
            image: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'],
            // 视频类型
            video: ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'],
            // 音频类型
            audio: ['mp3', 'wav', 'ogg', 'aac', 'm4a', 'flac']
          };

          // 查找文件类型
          for (const [type, extensions] of Object.entries(typeMap)) {
            if (extensions.includes(extension)) {
              return type;
            }
          }

          // 默认返回图片类型（兼容旧数据）
          return 'image';
        },
        getMediaProps(item) {
          const type = this.getFileType(item.name);
          const baseProps = {
            src: `/file/${item.name}`,
            fileName: item.name,
            metadata: item.metadata || {},
            selected: item.selected || false
          };

          // 根据类型返回特定属性
          switch (type) {
            case 'audio':
              return {
                ...baseProps,
                // 可以添加音频特定的属性
              };
            case 'video':
              return {
                ...baseProps,
                // 可以添加视频特定的属性
              };
            default:
              return {
                ...baseProps,
                // 图片特定的属性
                previewSrcList: [`/file/${item.name}`]
              };
          }
        }
      },
      mounted() {
        window.addEventListener('resize', this.calculatePageSize);
        this.updateWindowWidth();
        fetch("./api/manage/check", { method: 'GET', credentials: 'include' })
          .then(response => response.text())
          .then(result => result === "true" ? this.showLogoutButton = true : window.location.href = "./api/manage/login")
          .catch(() => this.$message.error('同步数据时出错，请检查网络连接'));

        fetch("./api/manage/list", { method: 'GET', credentials: 'include' })
          .then(response => response.json())
          .then(result => {
            console.log("result: ", result);
            this.tableData = result.map(file => ({
              ...file,
              selected: false,
              metadata: {
                ...file.metadata,
                liked: file.metadata.liked ?? false
              }
            }));
            this.updateStats();
            const savedSortOption = localStorage.getItem('sortOption');
            if (savedSortOption) {
              this.sortOption = savedSortOption;
            }
            this.sortData(this.tableData);
          })
          .catch(() => this.$message.error('同步数据时出错，请检查网络连接'));

        // 恢复用户偏好的文件类型
        const savedFileType = localStorage.getItem('fileType');
        if (savedFileType) {
          this.switchFileType(savedFileType);
        }
      },
      beforeDestroy() {
        window.removeEventListener('resize', this.calculatePageSize);
      }
    });
  </script>
  </html>